# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_stores.ipynb.

# %% ../nbs/00_stores.ipynb 1
from __future__ import annotations
from typing import Callable, TypeVar,  Generic, Union, Optional, Set, Protocol, Any
from typing_extensions import Annotated
from fastcore.test import test_eq, test, test_fail
from fastcore.basics import patch

# %% auto 0
__all__ = ['T', 'covT', 'Subscriber', 'Unsubscriber', 'Updater', 'Notifier', 'StoreProtocol', 'Writable', 'Readable', 'Derived']

# %% ../nbs/00_stores.ipynb 7
T = TypeVar("T")
covT = TypeVar("covT", covariant=True)
Subscriber = Callable[[T], None] # a callback
Unsubscriber = Callable[[], None] # a callback to be used upon termination of the subscription    
Updater = Callable[[T], T]

# %% ../nbs/00_stores.ipynb 8
class StoreProtocol(Protocol, Generic[covT]):
    ''' The Svelte Store ~~contract~~ protocol. '''
    def subscribe(self, subscriber: Subscriber[T]) -> Unsubscriber: ...

# %% ../nbs/00_stores.ipynb 9
class Store(StoreProtocol[T]):
    ''' A base class for all stores.'''
    value: T
    subscribers: Set[Subscriber]
    def __init__(self, /, **kwargs): 
        self.__dict__.update(kwargs) # see SimpleNamespace: https://docs.python.org/3/library/types.html
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.get()!r})"
    def subscribe(self, callback: Subscriber) -> Unsubscriber:
        return lambda: None
    def get(self) -> T: return self.value

class Readable(Store[T]): pass

class Writable(Store[T]):
    set: Subscriber
    update: Optional[Callable[[Updater],None]] = None

# %% ../nbs/00_stores.ipynb 12
from .util import safe_not_equal

# %% ../nbs/00_stores.ipynb 13
class Writable(Store[T]):
    ''' A Writable Store.'''
    def __init__(self, 
                 initial_value: T = None # the initial value of the store
                 ) -> None:
        self.value: T = initial_value
        self.subscribers: Set[Subscriber] = set() # callbacks to be called when the value changes

    def subscribe(self, callback: Subscriber) -> Unsubscriber:
        self.subscribers.add(callback)
        callback(self.value)

        def unsubscribe() -> None:
            # the unsubscribe can be called multiple times, 
            # so we need to check if the callback is still in the set
            self.subscribers.remove(callback) if callback in self.subscribers else None
        return unsubscribe
    
    def set(self, new_value: T) -> None:
        if (safe_not_equal(self.value, new_value)):
            self.value = new_value
            for subscriber in self.subscribers:
                subscriber(new_value)
                
    def update(self, fn: Callable[[T], T]) -> None:
        self.set(fn(self.value))
    
    def __len__(self) -> int:
        ''' The length of the store is the number of subscribers.'''
        return len(self.subscribers)

# %% ../nbs/00_stores.ipynb 44
Notifier = Callable[[Subscriber], Union[Unsubscriber, None]]

# %% ../nbs/00_stores.ipynb 45
@patch 
def __init__(self:Writable,
                initial_value: Any = None, # The initial value of the store
                start: Notifier = lambda x: None # A Notifier (Optional)
                ) -> None:
    self.value = initial_value
    self.subscribers: Set[Subscriber] = set() #type: ignore
    self.stop: Optional[Unsubscriber] = None  #type: ignore
    self.start: Notifier = start              #type: ignore


@patch
def subscribe(self:Writable, callback: Subscriber) -> Unsubscriber:
    self.subscribers.add(callback)
    if (len(self.subscribers) == 1):
        self.stop = self.start(callback) or (lambda: None) #type: ignore
    callback(self.value)

    def unsubscribe() -> None:
        self.subscribers.remove(callback) if callback in self.subscribers else None
        if (len(self.subscribers) == 0):
            self.stop() if self.stop else None #type: ignore
            self.stop = None #type: ignore
    return unsubscribe

# %% ../nbs/00_stores.ipynb 61
class Readable(Writable[T]):
    ''' A Readable Store.''' 
    def __init__(self, 
                 initial_value: T, # The initial value of the store
                 start: Notifier # A Notifier 
                ) -> None:
        super().__init__(initial_value, start)
    def set(self, *args, **kwargs): raise Exception("Cannot set a Readable Store.")
    def update(self, *args, **kwargs): raise Exception("Cannot update a Readable Store.")

# %% ../nbs/00_stores.ipynb 75
class Derived(Writable):
    ''' A Derived Store.'''
    def __init__(self,
                  source: Store, # The source store
                  fn: Updater # A function that takes the source store's value and returns a new value
                  ) -> None:
        self.target = Writable(source.get())
        self.start: Notifier = lambda x: self.target.set(fn(x))
        self.stop = source.subscribe(self.start)
    def get(self) -> T: return self.target.get()
    def set(self, *args, **kwargs): raise Exception("Cannot set a Derived Store.")
    def update(self, *args, **kwargs): raise Exception("Cannot update a Derived Store.")
    def subscribe(self, callback: Subscriber) -> Unsubscriber:
        return self.target.subscribe(callback)

# %% ../nbs/00_stores.ipynb 96
@patch # does not like type annotations
def __init__(self:Derived, 
             s: Union[Store, list[Store]],
             fn: Callable,
             ) -> None:
    isStore = isinstance(s, Store)
    isList = isinstance(s, list) and all([isinstance(x, Store) for x in s])
    if not isStore and not isList: raise Exception("s must be a Store or a list of Stores")
    self.sources:list[Store] = [s] if isStore else s # type: ignore
    self.fn = fn # type: ignore
    self.target = Writable(None)
    self.unsubscribers = [(lambda s=s: s.subscribe(self._update))(s) for s in self.sources] # type: ignore

@patch
def _update(self:Derived, x): # ignore the new value and just refresh the target from sources
    values = [(lambda s=s: s.get())(s) for s in self.sources] # type: ignore
    self.target.set(self.fn(*values)) # type: ignore
