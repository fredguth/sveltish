[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sveltish",
    "section": "",
    "text": "Svelte Stores are one of the secret weapons of the Svelte framework (the recently voted most loved web framework).\nStores allow easy reactive programming by presenting an Observer pattern that is as simple as necessary, but not simpler."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Sveltish",
    "section": "Install",
    "text": "Install\npip install sveltish"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Sveltish",
    "section": "How to use",
    "text": "How to use\nSometimes, you’ll have values that need to be accessed by multiple unrelated objects.\nFor that, you can use stores. It is a very simple implementation (around 100 lines of code) of the Observer/Observable pattern.\nA store is simply an object with a subscribe method that allows interested parties to be notified when its value changes.\n\nWritable Stores\n\nfrom sveltish.stores import writable\n\n\ncount = writable(0)\nhistory = []  # logging for testing\n# subscribe returns an unsubscriber\ndef record(x): \n    history.append(x)\n    print(history)\nstop = count.subscribe(record)\n\ntest_eq(history, [0])\n\n[0]\n\n\nWe just created a count store. Its value can be accessed via a callback we pass in the count.subscribe method:\nA Writable can be set from the outside. When it happens, all its subscribers will react.\n\ndef increment(): count.update(lambda x: x + 1)\ndef decrement(): count.update(lambda x: x - 1)\ndef reset(): count.set(0)\n\ncount.set(3)\nincrement()\ndecrement()\ndecrement()\nreset()\ncount.set(42)\n\ntest_eq(history, [0, 3, 4, 3, 2, 0, 42])\n\n[0, 3]\n[0, 3, 4]\n[0, 3, 4, 3]\n[0, 3, 4, 3, 2]\n[0, 3, 4, 3, 2, 0]\n[0, 3, 4, 3, 2, 0, 42]\n\n\nThe unsubscriber, in this example the stop function, stops the notifications to the subscriber.\n\nstop()\nreset()\ncount.set(22)\ntest_eq(history, [0, 3, 4, 3, 2, 0, 42])\ncount\n\nw<0> $int: 22\n\n\nNotice that you can still change the store but there was no print message this time. There was no observer listening.\n\n\n\n\n\n\nNote\n\n\n\nObserver, Subscriber and Callback are used as synomyms here.\n\n\nWhen we subscribe new callbacks, they will be promptly informed of the current state of the store.\n\nstop  = count.subscribe(lambda x: print(f\"Count is now {x}\"))\nstop2 = count.subscribe(lambda x: print(f\"double of count is {2*x}\"))\n\nCount is now 22\ndouble of count is 44\n\n\n\nreset()\n\nCount is now 0\ndouble of count is 0\n\n\n\nstop()\nstop2()\n\nYou can create an empty Writable Store.\n\nstore = writable()\nhistory = []\nunsubscribe = store.subscribe(lambda x: history.append(x))\nunsubscribe()\ntest_eq(history, [None])\n\nIf you try to unsubscribe twice, it won’t break. It just does nothing the second time… and in the third time… and…\n\nunsubscribe(), unsubscribe(), unsubscribe()\n\n(None, None, None)\n\n\nStores assume mutable objects.\n\n\n\n\n\n\nNote\n\n\n\nIn Python everythong is an object. Here we are calling an object something that is not a primitive (eg. int, bool, etc)\n\n\n\nclass Bunch:\n    __init__ = lambda self, **kw: setattr(self, '__dict__', kw)\n\nobj = Bunch()\ncalled = 0\nstore = writable(obj)\ndef callback(x):\n    global called\n    called += 1\nstop = store.subscribe(callback)\n\n\ntest_eq(called, 1)\nobj.a = 1 #type: ignore\nstore.set(obj)\ntest_eq(called, 2)\n\n\n\nReadable Stores\nHowever… It is clear that not all stores should be writable by whoever has a reference to them. Many times you want a single publisher of change in store that is only consumed (subscribed) by many other objects. For those cases, we have readable stores.\n\n\n\n\n\n\nNote\n\n\n\nThe Publisher Subscriber (PubSub) pattern is a variant of the Observable/Observer pattern.\n\n\n\nfrom sveltish.stores import readable\n\nA Readable store without a start function is a constant value and has no meaning for us. Therefore, start is a required argument.\n\ntry:\n    c = readable(0) # shoud fail\nexcept Exception as error:\n    print(error)\n\ntest_fail(lambda: readable(0))\n\nreadable() missing 1 required positional argument: 'start'\n\n\n\nclass Publisher:\n    def __init__(self): self.set = lambda x: None\n    def set_set(self, set): \n        self.set = set\n        return lambda: None\n    def use_set(self, value): self.set(value)\n\n\np = Publisher()\nreader = readable(0, p.set_set)\nreader\n\nr<0> $int: 0\n\n\nThs store only starts updating after the first subscriber. Here, the publisher does not change the store.\n\np.use_set(1), reader\n\n(None, r<0> $int: 0)\n\n\n\nstop = reader.subscribe(lambda x: print(f\"reader is now {x}\"))\n\nreader is now 0\n\n\n\np.use_set(2)\n\nreader is now 2\n\n\n\nstop()\n\nAnother example of Readable Store usage:\n\nfrom threading import Event, Thread\nimport time\n\n\ndef start(set): # the start function is the publisher\n    stopped = Event()\n    def loop(): # needs to be in a separate thread\n        while not stopped.wait(1): # in seconds\n            set(time.localtime())\n    Thread(target=loop).start()    \n    return stopped.set\n\n\nnow = readable(time.localtime(), start)\nnow\n\nr<0> $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=41, tm_wday=2, tm_yday=67, tm_isdst=0)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe loop needs to be in its own thread, otherwise the function would never return and we would wait forever.\n\n\nWhile there is no subscriber, the Readable will not be updated.\n\nnow\n\nr<0> $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=41, tm_wday=2, tm_yday=67, tm_isdst=0)\n\n\n\nOhPleaseStop = now.subscribe(lambda x: print(time.strftime(f\"%H:%M:%S\", x), end=\"\\r\"))\n\n22:12:41\n\n\n\ntime.sleep(2)\nOhPleaseStop()\n\n22:12:43\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Svelte Store api allow you to create a Readable Store without a Notifier. See discussion here.\n\n\n\n\nDerived Stores\nA Derived Store stores a value based on the value of another store.\n\nfrom sveltish.stores import derived\n\nFor example:\n\ncount = writable(1)\nstopCount = count.subscribe(lambda x: print(f\"count is {x}\"))\ndouble = derived(count, lambda x: x * 2)\nstopDouble = double.subscribe(lambda x: print(f\"double is {x}\"))\ntest_eq(double.get(), 2*count.get())\n\ncount is 1\ndouble is 2\n\n\n\ncount.set(2)\ntest_eq(double.get(), 4)\n\ncount is 2\ndouble is 4\n\n\n\nstopCount(), stopDouble()\n\n(None, None)\n\n\nBuilding on our previous example, we can create a store that derives the elapsed time since the original store was started.\n\nelapsing = None\ndef calc_elapsed(now):\n    global elapsing\n    if not elapsing: \n        elapsing = now\n    return time.mktime(now) - time.mktime(elapsing)\n\n\nnow\n\nr<0> $struct_time: time.struct_time(tm_year=2023, tm_mon=3, tm_mday=8, tm_hour=22, tm_min=12, tm_sec=43, tm_wday=2, tm_yday=67, tm_isdst=0)\n\n\n\nelapsed = derived(now, lambda x: calc_elapsed(x))\nelapsed\n\nr<0> $float: 0.0\n\n\n\nstopElapsed = elapsed.subscribe(lambda x: print(f\"Elapsed time of source store: {x} seconds.\", end=\"\\r\"))\n\nElapsed time of source store: 0.0 seconds.\n\n\n\ntime.sleep(1)\nstopElapsed()\n\nElapsed time of source store: 2.0 seconds.\n\n\nDerived stores allow us to transform the value of a store. In RxPy they are called operators. You can build several operators like: filter, fold, map, zip…\nLet’s build a custom filter operator:\n\nuser = writable({\"name\": \"John\", \"age\": 32})\nstopLog = user.subscribe(lambda x: print(f\"User: {x}\"))\n\nUser: {'name': 'John', 'age': 32}\n\n\n\nname = derived(user, lambda x: x[\"name\"])\nstopName = name.subscribe(lambda x: print(f\"Name: {x}\"))\n\nName: John\n\n\n\nuser.update(lambda x: x | {\"age\": 45})\n\nUser: {'name': 'John', 'age': 45}\n\n\nUpdating the age does not trigger the name subscriber. Let’s see what happens when we update the name.\n\nuser.update(lambda x: x | {\"name\": \"Fred\"})\n\nName: Fred\nUser: {'name': 'Fred', 'age': 45}\n\n\nOnly changes to the name of the user triggers the name subscriber.\n\nstopName(), stopLog()\n\n(None, None)\n\n\nAnother cool thing about Derived Stores is that you can derive from a list of stores. Let’s build a zip operator.\n\na = writable([1,2,3,4])\nb = writable([5,6,7,8])\na,b\n\n(w<0> $list: [1, 2, 3, 4], w<0> $list: [5, 6, 7, 8])\n\n\n\nzipper = derived([a,b], lambda a,b: list(zip(a,b)))\n\n\ntest_eq(zipper.get(), [(1, 5), (2, 6), (3, 7), (4, 8)])\n\nWhile zipper has no subscribers, it keeps the initial value, it is stopped.\n\na.set([4,3,2,1])\ntest_eq(zipper.get(), [(1, 5), (2, 6), (3, 7), (4, 8)])\n\nA subscription starts zipper and it will start to react to the changes of the stores.\n\nu = zipper.subscribe(lambda x: None)\ntest_eq(zipper.get(), [(4, 5), (3, 6), (2, 7), (1, 8)])\n\n\nb.set([8,7,6,5])\ntest_eq(zipper.get(), [(4, 8), (3, 7), (2, 6), (1, 5)])\n\n\nu()\n\n\n\nStore composition with pipes\n\nwritable(1).pipe(lambda x: x + 1).pipe(lambda x: x * 2)\n\nr<0> $int: 4\n\n\n\nwritable(1).pipe(lambda x: x+1, lambda x: x*2)\n\nr<0> $int: 4\n\n\n\nwritable(1) | (lambda x: x+1) | (lambda x: x*2)\n\nr<0> $int: 4\n\n\n\na = writable(1)\nu5 = (a \n      | (lambda x: x*2) \n      | (lambda x: x*2) \n      | (lambda x: x*2)).subscribe(lambda x: print(f\"u5: {x}\"))\n\nu5: 8\n\n\n\na.set(2)\n\nu5: 16\n\n\n\nu5()"
  },
  {
    "objectID": "index.html#missing-features",
    "href": "index.html#missing-features",
    "title": "Sveltish",
    "section": "Missing features",
    "text": "Missing features\nYou may have noticed that along the way we had always to subscribe and then had to remember to unsubscribe when we were done. This is a bit of a nuisance. Svelte has a compiler that provide some syntatic sugar to make this easier. They call it auto-subscriptions.\nSveltish does not have auto-subscriptions yet. But if you have a nice idea how to implement it, please let me know."
  },
  {
    "objectID": "03_signals.html",
    "href": "03_signals.html",
    "title": "sveltish",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "03_signals.html#tests",
    "href": "03_signals.html#tests",
    "title": "sveltish",
    "section": "Tests",
    "text": "Tests\n\ncount, setCount = writable(0).asTuple()\n\n\nhistory = []  # logging for testing\n\ndef record(x): \n    history.append(x)\n    print(history)\nlogger = reaction(lambda: record(count()))\n\ntest_eq(history, [0])\n\n[0]\n\n\n\ndef increment(): setCount(count()+1)\ndef decrement(): setCount(count()-1)\ndef reset(): setCount(0)\n\nsetCount(3)\nincrement()\ndecrement()\ndecrement()\nreset()\nsetCount(42)\n\ntest_eq(history, [0, 3, 4, 3, 2, 0, 42])\n\n[0, 3]\n[0, 3, 4]\n[0, 3, 4, 3]\n[0, 3, 4, 3, 2]\n[0, 3, 4, 3, 2, 0]\n[0, 3, 4, 3, 2, 0, 42]\n\n\n\nlogger.cancel()\nreset()\nsetCount(22)\ntest_eq(history, [0, 3, 4, 3, 2, 0, 42])\n\n\neffect1 = reaction(lambda: print(f'Count is now {count()}'))\neffect2 = reaction(lambda: print(f'double of the count is {count()*2}'))\n\nCount is now 22\ndouble of the count is 44\n\n\n\nreset()\n\nCount is now 0\ndouble of the count is 0\n\n\n\neffect1.cancel()\neffect2.cancel()\n\n\nhistory = []\ns, set_fn = writable().asTuple()\n\n\nlogger = reaction(lambda: history.append(s()))\nlogger.cancel()\ntest_eq(history, [None])\n\n\nfrom threading import Event, Thread\nimport time\n\n\ndef start(set): # the start function is the publisher\n    stopped = Event()\n    def loop(): # needs to be in a separate thread\n        while not stopped.wait(1): # in seconds\n            set(time.localtime())\n    Thread(target=loop).start()    \n    return stopped.set\n\n\ntimer, set_fn = writable(time.localtime()).asTuple()\nlog = reaction(lambda: print(time.strftime(f\"%H:%M:%S\", timer())))\n\n15:41:35\n\n\n\nstop = start(set_fn)\ntime.sleep(2)\nstop()\n\n15:41:36\n15:41:37\n\n\n\ncount, setCount = writable(0).asTuple()\nlogCount = reaction(lambda: print(f'count is {count()}'))\n\ncount is 0\n\n\n\ndouble = computed(lambda: count()*2) #type: ignore\nsetCount(7)\ntest_eq(double(), 14)\n\ncount is 7\n\n\n\nlogCount.cancel()\n\n\nelapsing = None\ndef calc_elapsed(now):\n    global elapsing\n    if not elapsing: \n        elapsing = now\n    return time.mktime(now) - time.mktime(elapsing)\n\n\ntimer()\n\ntime.struct_time(tm_year=2023, tm_mon=3, tm_mday=15, tm_hour=15, tm_min=41, tm_sec=37, tm_wday=2, tm_yday=74, tm_isdst=0)\n\n\n\nelapsed = computed(lambda: calc_elapsed(timer()))\nelapsed()\n\n0.0\n\n\n\nstop = start(set_fn)\ntime.sleep(2)\nstop()\n\n15:41:39\n15:41:40\n\n\n\na = writable([1,2,3,4])\nb = writable([5,6,7,8])\nzipper = computed(lambda: list(zip(a.read(), b.read())))\ntest_eq(zipper(), [(1, 5), (2, 6), (3, 7), (4, 8)])\na.write([4,3,2,1])\ntest_eq(zipper(), [(4, 5), (3, 6), (2, 7), (1, 8)])\nb.write([8,7,6,5])\ntest_eq(zipper(), [(4, 8), (3, 7), (2, 6), (1, 5)])\n\n\nhistory = []\nfirstName, setFirstName = writable(\"John\").asTuple()\nlastName, setLastName = writable(\"Smith\").asTuple()\nfullName = lambda: f'{firstName()} {lastName()}'\nshowFullName, setShowFullName = writable(True).asTuple()\ndisplayName = reaction(lambda: history.append(fullName() if showFullName() else firstName()))\n\n\ntest_eq(history, ['John Smith'])\nsetShowFullName(False)\ntest_eq(history, ['John Smith', 'John'])\nsetShowFullName(True)\ntest_eq(history, ['John Smith', 'John', 'John Smith'])"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nnoop\n\n noop (*args, **kwargs)\n\n\nsource\n\n\nidentity\n\n identity (x)\n\n\nsource\n\n\nsafe_not_equal\n\n safe_not_equal (a, b)\n\nCheck if a is not equal to b\n\nsource\n\n\ncompose\n\n compose (*functions)\n\nCompose multiple functions left to right.\nExamples:\ncompose()(x) = x \ncompose(f)(x) = f(x) \ncompose(f, g)(x) = g(f(x)) \n...\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunctions\n\n\n\n\nReturns\ntyping.Callable[[typing.Any], typing.Any]\ncomposed function\n\n\n\n\nsource\n\n\nNamedBunch\n\n NamedBunch (name, **kw)\n\n\nsource\n\n\nBunch\n\n Bunch (**kw)"
  },
  {
    "objectID": "stores.html",
    "href": "stores.html",
    "title": "stores",
    "section": "",
    "text": "A store must contain a .subscribe method, which must accept as its argument a subscription function(aka Subscriber or Callback). This subscription function must be immediately and synchronously called with the store’s current value upon calling subscribe. All of a store’s active subscription functions must later be synchronously called whenever the store’s value changes.\nThe .subscribe method must return an unsubscribe function(aka Unsubscriber). Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store.\nA store may optionally contain a .set method, which must accept as its argument a new value for the store, and which synchronously calls all of the store’s active subscription functions. Such a store is called a writable store.\n\nFor interoperability with RxJS Observables, the .subscribe method is also allowed to return an object with an .unsubscribe method, rather than return the unsubscription function directly. Note however that unless .subscribe synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as undefined until it does.\nStore Contract Documentation\n\n\n\nT = TypeVar(\"T\")\ncovT = TypeVar(\"covT\", covariant=True)\nSubscriber = Callable[[T], None] # a callback\nUnsubscriber = Callable[[], None] # a callback to be used upon termination of the subscription\nUpdater = Callable[[T], T]\nNotifier = Callable[[Subscriber], Union[Unsubscriber, None]]\n\nclass StoreProtocol(Protocol, Generic[covT]):\n    ''' The Svelte Store ~~contract~~ protocol. '''\n    def subscribe(self, subscriber: Subscriber[T]) -> Unsubscriber: ...\n\nReadable: TypeAlias = StoreProtocol[T]\n\nclass Writable(Readable[T]):\n    ''' Writable protocol'''\n    def set(self, value: T) -> None: ...\n    def update(self, updater: Updater[T]) -> None: ...\n\n\nsource\n\n\n\n\n Writable (*args, **kwargs)\n\nWritable protocol\n\nsource\n\n\n\n\n StoreProtocol (*args, **kwargs)\n\nThe Svelte Store contract protocol."
  },
  {
    "objectID": "stores.html#implementation",
    "href": "stores.html#implementation",
    "title": "stores",
    "section": "Implementation",
    "text": "Implementation\n\nWritable Store\n\nsource\n\n\nStore\n\n Store (initial_value:Any=None, start:Notifier=<function noop>)\n\nA Writable Store.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninitial_value\nAny\nNone\ninitial value of the store\n\n\nstart\nNotifier\nnoop\nA Notifier (Optional)\n\n\nReturns\nNone\n\n\n\n\n\n\nWritable Factory\n\nsource\n\n\n\nwritable\n\n writable (value:~T=None, start:Callable[[Callable[[~T],NoneType]],Optiona\n           l[Callable[[],NoneType]]]=<function noop>)\n\nCreates a new Writable Store (A Writable factory).\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvalue\nT\nNone\ninitial value of the store\n\n\nstart\nNotifier\nnoop\nOptional Notifier, a function called when the first subscriber is added\n\n\nReturns\nWritable[T]\n\nWritable Store\n\n\n\n\nReadable Store\n\nsource\n\n\n\nReadableStore\n\n ReadableStore (initial_value:T, start:Notifier)\n\nA Readable Store.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ninitial_value\nT\ninitial value of the store\n\n\nstart\nNotifier\nfunction called when the first subscriber is added\n\n\nReturns\nNone\n\n\n\n\n\nReadable Factory\n\nsource\n\n\n\nreadable\n\n readable (value:~T, start:Callable[[Callable[[~T],NoneType]],Optional[Cal\n           lable[[],NoneType]]])\n\nCreates a new Readable Store (A Readable factory).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvalue\nT\ninitial value of the store\n\n\nstart\nNotifier\nfunction called when the first subscriber is added\n\n\nReturns\nReadable[T]\nReadable Store\n\n\n\n\nDerived Store\n\nsource\n\n\n\nDerivedStore\n\n DerivedStore (s:Union[Store,list[Store]], *functions:Callable)\n\nA Derived Store.\n\n\n\n\nType\nDetails\n\n\n\n\ns\nUnion[Store, listStore]\nsource store(s)\n\n\nfunctions\nCallable\n\n\n\nReturns\nNone\na callback that takes the source store(s) values and returns the derived value\n\n\n\n\nDerived Factory\n\nsource\n\n\n\nderived\nCreates a new Derived Store (A Derived factory).\n\nd = derived(a, lambda a: f\"{a}\")\nd\n\nr<0> $str: 'fonzie'\n\n\n\nPipe Operator\n\nsource\n\n\n\nshow_doc\n\n show_doc (sym, renderer=None, name:Optional[str]=None, title_level:int=3)\n\nShow signature and docstring for sym\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsym\n\n\nSymbol to document\n\n\nrenderer\nNoneType\nNone\nOptional renderer (defaults to markdown)\n\n\nname\nstr | None\nNone\nOptionally override displayed name of sym\n\n\ntitle_level\nint\n3\nHeading level to use for symbol name"
  }
]